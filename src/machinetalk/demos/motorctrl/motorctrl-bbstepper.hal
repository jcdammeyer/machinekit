# set logging to 'pretty high'
log rt 5
log user 5

# start haltalk server
# add -d or -d -d to log message transactions
loadusr -W haltalk

# the control setup

# syntax: newthread <name> <periodns> [fp|nofp] [cpu=<int>]
# default is nofp
newthread servo-thread 1000000 fp

loadrt limit3
loadrt lowpass

# differentiate pos to get vel, vel to get acc
loadrt ddt names=actvel,actacc

# load low-level drivers
loadrt hal_bb_gpio output_pins=103,105,107,120,128,140,141 input_pins=131,132,133,135,137,138
loadrt [PRUCONF](DRIVER) prucode=$(LINUXCNC_HOME)/[PRUCONF](PRUBIN) [PRUCONF](CONFIG)

addf [PRUCONF](DRIVER).capture-position   servo-thread
addf bb_gpio.read                         servo-thread
addf limit3.0 servo-thread
addf lowpass.0 servo-thread
addf actvel servo-thread
addf actacc servo-thread
addf [PRUCONF](DRIVER).update             servo-thread
addf bb_gpio.write                        servo-thread


net stepper.enable => [PRUCONF](DRIVER).stepgen.00.enable bb_gpio.p8.out-41
setp bb_gpio.p8.out-41.invert 1

# BeBoPr Enable
net stepper.enable =>  bb_gpio.p8.out-03
net stepper.enable =>  bb_gpio.p8.out-05
setp bb_gpio.p8.out-05.invert 1

# BeBoPr ECO locations for enable signalsto avoid eMMC noise on startup:
# Enable (P8.3) tied to system Reset_n line (P9.10)
net estop-loop => bb_gpio.p8.out-07
setp bb_gpio.p8.out-07.invert 1

#net stepper.pos-cmd => [PRUCONF](DRIVER).stepgen.00.position-cmd

# timing parameters
setp [PRUCONF](DRIVER).stepgen.00.dirsetup        [AXIS_0]DIRSETUP
setp [PRUCONF](DRIVER).stepgen.00.dirhold         [AXIS_0]DIRHOLD

setp [PRUCONF](DRIVER).stepgen.00.steplen         [AXIS_0]STEPLEN
setp [PRUCONF](DRIVER).stepgen.00.stepspace       [AXIS_0]STEPSPACE

setp [PRUCONF](DRIVER).stepgen.00.position-scale  [AXIS_0]SCALE

setp [PRUCONF](DRIVER).stepgen.00.maxvel          [AXIS_0]STEPGEN_MAX_VEL
setp [PRUCONF](DRIVER).stepgen.00.maxaccel        [AXIS_0]STEPGEN_MAX_ACC

#setp [PRUCONF](DRIVER).stepgen.00.step_type       0
# P8.43 PRU1.out2
setp [PRUCONF](DRIVER).stepgen.00.steppin         0xA2
# P8.44 PRU1.out4
setp [PRUCONF](DRIVER).stepgen.00.dirpin          0xA3



# wait the halcmd script until the UI has created the remote component 'motorctrl':
# waitexists motorctrl

# OR preconfigure the remote component like so
# in this case no waiting required
# pin count, name, type, direction must match exactly what
# is in the GUI
sete 1 0.001
newcomp motorctrl timer=100 # acceptdefaults
newpin motorctrl motorctrl.cmd_maxacc    float out
newpin motorctrl motorctrl.cmd_maxvel    float out
newpin motorctrl motorctrl.cmd_pos       float out
newpin motorctrl motorctrl.fb_acc        float in eps=1
newpin motorctrl motorctrl.fb_acc.scale  float in eps=1
newpin motorctrl motorctrl.fb_pos        float in eps=1
newpin motorctrl motorctrl.fb_pos.scale  float in eps=1
newpin motorctrl motorctrl.fb_vel        float in eps=1
newpin motorctrl motorctrl.fb_vel.scale  float in eps=1
newpin motorctrl motorctrl.led1          bit in
newpin motorctrl motorctrl.lowpass_gain  float out
newpin motorctrl motorctrl.scope_trigger bit out
newpin motorctrl motorctrl.togglebutton1 bit out
newpin motorctrl motorctrl.togglebutton1-not bit out
ready  motorctrl

# set default pin values here
# setting acceptdefaults on the newcomp statement would enable
# accepting default values from the remote component
# however, this will cause a jump of values on connect
setp motorctrl.lowpass_gain 0.1
setp motorctrl.cmd_maxacc 25
setp motorctrl.cmd_maxvel 25

# at this stage, the component and its pins exist
# and can be linked to

net cmd-pos motorctrl.cmd_pos =>       limit3.0.in
net cmd-maxvel motorctrl.cmd_maxvel => limit3.0.maxv
net cmd-maxacc motorctrl.cmd_maxacc => limit3.0.maxa

net raw-pos  limit3.0.out => lowpass.0.in
net gain     motorctrl.lowpass_gain => lowpass.0.gain

net curr-pos lowpass.0.out => motorctrl.fb_pos actvel.in [PRUCONF](DRIVER).stepgen.00.position-cmd
net curr-vel actvel.out =>   actacc.in motorctrl.fb_vel
net curr-acc actacc.out =>   motorctrl.fb_acc

# make led follow togglebutton for now:
#net led motorctrl.led1 <== motorctrl.togglebutton1

#use togglebutton as motor enable
net stepper.enable <== motorctrl.togglebutton1

# make trigger pin a signal - halscope wants signals to trigger on:
net scope-trigger motorctrl.scope_trigger



# start the gladevcp version

# use the environment UUID to determine the target instance
# no -N flag - local case, use IPC sockets, no zeroconf resolution
loadusr -Wn motorctrl gladevcp -E -u motorctrl.py motorctrl.ui

# -N - remote case, use zeroconf resolution
#loadusr -Wn motorctrl gladevcp -N -E -u motorctrl.py motorctrl.ui

# load scope only now - because all sigs are now defined:
#loadusr halscope


start
